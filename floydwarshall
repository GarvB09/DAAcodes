import math

# =====================================
# Floyd–Warshall Algorithm with Path
# =====================================

def floyd_warshall(dist, nxt):
    n = len(dist)
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] == math.inf or dist[k][j] == math.inf:
                    continue
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    nxt[i][j] = nxt[i][k]

def get_path(u, v, nxt):
    """Reconstruct the shortest path from u → v."""
    if nxt[u][v] == -1:
        return []
    path = [u]
    while u != v:
        u = nxt[u][v]
        path.append(u)
    return path


# =====================================
# Main Program
# =====================================
if __name__ == "__main__":
    INF = math.inf
    V = 4

    # Adjacency matrix
    dist = [
        [0,   3, INF, 7],
        [8,   0,   2, INF],
        [5, INF,   0, 1],
        [2, INF, INF, 0]
    ]

    city_names = ["CityA", "CityB", "CityC", "CityD"]

    # Initialize next matrix for path reconstruction
    nxt = [[-1]*V for _ in range(V)]
    for i in range(V):
        for j in range(V):
            if dist[i][j] != INF and i != j:
                nxt[i][j] = j

    # Run algorithm
    floyd_warshall(dist, nxt)

    # Display shortest distance matrix
    print("\nShortest Distance Matrix:")
    for row in dist:
        print("\t".join("INF" if x == INF else str(x) for x in row))

    # Example: Find shortest path from CityA → CityD
    src, dest = 0, 3
    print(f"\nShortest path from {city_names[src]} to {city_names[dest]}:")

    path = get_path(src, dest, nxt)
    if path:
        print(" -> ".join(city_names[i] for i in path))
        print(f"Total Distance: {dist[src][dest]}")
    else:
        print("No path exists.")

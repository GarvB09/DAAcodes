# ================================
# Floydâ€“Warshall Algorithm (Python)
# with Path Reconstruction
# ================================

import math

def floyd_warshall(dist, nxt):
    n = len(dist)
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] == math.inf or dist[k][j] == math.inf:
                    continue
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    nxt[i][j] = nxt[i][k]


def get_path(u, v, nxt):
    if nxt[u][v] == -1:
        return []
    path = [u]
    while u != v:
        u = nxt[u][v]
        path.append(u)
    return path


# ================================
# Main Program
# ================================
if __name__ == "__main__":
    INF = math.inf
    V = 4

    # Adjacency matrix
    dist = [
        [0,   3, INF, 7],
        [8,   0,   2, INF],
        [5, INF,   0, 1],
        [2, INF, INF, 0]
    ]

    # City names
    city_names = ["CityA", "CityB", "CityC", "CityD"]

    # Initialize next matrix
    nxt = [[-1]*V for _ in range(V)]
    for i in range(V):
        for j in range(V):
            if dist[i][j] != INF and i != j:
                nxt[i][j] = j

    # Run algorithm
    floyd_warshall(dist, nxt)

    # Print shortest distance matrix
    print("\nShortest Distance Matrix:")
    for i in range(V):
        for j in range(V):
            print("INF" if dist[i][j] == INF else dist[i][j], end="\t")
        print()

    # Example: Find shortest path
    src, dest = 0, 3
    print(f"\nShortest path from {city_names[src]} to {city_names[dest]}:")

    path = get_path(src, dest, nxt)
    if not path:
        print("No path exists.")
    else:
        print(" -> ".join(city_names[i] for i in path))
        print(f"Total Distance: {dist[src][dest]}")

